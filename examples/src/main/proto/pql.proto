// Copyright 2015 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.predibase.pql.api";
option java_outer_classname = "PqlProto";
option objc_class_prefix = "PQL";

package pql;

// The greeting service definition.
service Parser {
  // Sends a greeting
  rpc Parse (ParseRequest) returns (ParseResponse) {}
}

// The request message containing the statement and target sql dialect
message ParseRequest {
  string statement = 1;
  enum TargetDialect {
    UNDEFINED = 0;
    MYSQL = 1;
    POSTGRESQL = 2;
    SNOWFLAKE = 3;
    REDSHIFT = 4;
    BIGQUERY = 5;
  }
  TargetDialect targetDialect = 2;
}

// The response message containing the clause type and properties and target sql
message ParseResponse {
  enum ClauseType {
    UNDEFINED = 0;
    NATIVE_SQL = 1;
    // ddl commands
    CREATE_CONNECTION = 10;
    DROP_CONNECTION = 11;
    CREATE_DATASET = 12;
    DROP_DATASET = 13;
    CREATE_MODEL = 14;
    DROP_MODEL = 15;
    // predict commands
    PREDICT = 100;
    EVALUATE = 101;
    VISUALIZE = 102;
    // show commands
    SHOW_MODELS = 200;
    SHOW_METRICS = 201;
    PLOT_METRICS = 202;
  }
  optional ParseError parseError = 1;
  ClauseType clauseType = 2;
  Clause clause = 3;
  string parsedSql = 4;
}

message ParseError {
  string message = 1;
  ParserPos position = 2;
  repeated string expectedTokens = 3;
}

message ParserPos {
  int32 lineNumber = 1;
  int32 columnNumber = 2;
  int32 endLineNumber = 3;
  int32 endColumnNumber = 4;
}

// Clause is one of the following (matching ClauseType enum)
message Clause {
  optional NativeSqlClause nativeSqlClause = 1;
  optional CreateConnectionClause createConnection = 10;
  optional CreateDatasetClause createDataset = 11;
  optional CreateModelClause createModel = 12;
  optional PredictClause predictClause = 100;
}

message NativeSqlClause {
  string query = 1;
}

message CreateConnectionClause {
  enum ConnectionType {
    UNDEFINED = 0;
    ADLS = 1;
    GCS = 2;
    S3 = 3;
    MYSQL = 4;
    POSTGRESQL = 5;
    SNOWFLAKE = 6;
    REDSHIFT = 7;
    BIGQUERY = 8;
  }
  string name = 1;
  ConnectionType connectionType = 2;
  map<string, string> secretProperties = 4;
  bool enabled = 9;
}

message CreateDatasetClause {
  string name = 1;
  optional DatasetRef target = 2;
  optional DatasetRef source = 3;
  optional string query = 4;
}

message DatasetRef {
  string tableRef = 1;
  map<string, string> formatProperties = 2;
}

message CreateModelClause {
  string name = 1;
  string config = 2;
  repeated Feature featureList = 3;
  repeated string targetList = 4;
  map<string, GivenItem> combiner = 5;
  map<string, GivenItem> trainer = 6;
  repeated string splitByList = 7;
  optional DatasetRef sourceRef = 8;
  optional string query = 9;
}

message Feature {
  enum FeatureType {
    UNDEFINED = 0;
    BINARY = 1;
    NUMERIC = 2;
    CATEGORY = 3;
    SET = 4;
    BAG = 5;
    SEQUENCE = 6;
    TEXT = 7;
    TIMESERIES = 8;
    AUDIO = 9;
    IMAGE = 10;
    DATE = 11;
    GEOMETRY = 12;
    VECTOR = 13;
  }
  string name = 1;
  FeatureType type = 2;
  map<string, GivenItem> encoder = 4;
  map<string, GivenItem> decoder = 5;
}

message PredictClause {
  enum PredictType {
    UNDEFINED = 0;
    PREDICT = 1;
    EVALUATE = 2;
  }
  PredictType predictType = 1;
  repeated string targetList = 2;
  enum WithQualifier {
    EMPTY = 0;
    EXPLANATION = 1;
    CONFIDENCE = 2;
  }
  optional WithQualifier withQualifier = 3;
  string into = 4;
  string model = 5;
  optional int32 version = 6;
  repeated GivenItem givenList = 7;
  repeated string query = 8;
}

message GivenItem {
  string name = 1;
  enum GivenType {
    UNDEFINED = 0;
    IDENTIFIER = 1;
    NUMERIC = 2;
    STRING = 3;
    ARRAY = 4;
    RANGE = 5;
  }
  GivenType type = 2;
  repeated string identifierValue = 3;
  // TODO: Do we need to discriminate by integer vs double
  repeated double numericValue = 4;
  repeated string stringValue = 5;
  optional double minValue = 6;
  optional double maxValue = 7;
  optional double stepValue = 8;
}
